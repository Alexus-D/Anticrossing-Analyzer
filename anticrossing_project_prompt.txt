ПРОМПТ ДЛЯ РЕАЛИЗАЦИИ АНАЛИЗАТОРА АНТИКРОССИНГА ФМР

=== ОПИСАНИЕ ПРОЕКТА ===

Задача: Создать инструмент для анализа антикроссинга между модами ферромагнитного резонанса (ФМР) и модой резонатора в экспериментальных данных S-параметров.

Проблема: В экспериментальных данных наблюдается несколько ФМР мод, каждая из которых может взаимодействовать с резонатором, создавая сложную картину антикроссинга. Стандартные методы анализа (поиск пиков, FWHM) не работают в области антикроссинга из-за искажения спектральных линий.

Решение: Гибридный подход - пользователь интерактивно размечает траектории мод на contour-графике, затем программа автоматически фитирует их теоретическими моделями антикроссинга для извлечения физических параметров (коэффициентов связи, затуханий и т.д.).

=== АРХИТЕКТУРА ПРОЕКТА ===

Структура папок:
```
anticrossing_analyzer/
├── __init__.py
├── main.py                          # Главный файл запуска
├── config/
│   ├── __init__.py
│   └── settings.py                  # Настройки проекта
├── core/
│   ├── __init__.py
│   ├── data_loader.py              # Загрузка данных (адаптер к существующему коду)
│   ├── trajectory_editor.py        # Интерактивное рисование траекторий мод
│   ├── fitting_engine.py           # Движок аппроксимации
│   └── results_manager.py          # Обработка и сохранение результатов  
├── models/
│   ├── __init__.py
│   ├── theoretical_functions.py    # Теоретические формулы для фитинга
│   └── model_selector.py           # Выбор подходящей модели по числу мод
├── visualization/
│   ├── __init__.py
│   ├── interactive_interface.py    # GUI для разметки траекторий
│   └── results_plotter.py         # Визуализация результатов фитинга
└── utils/
    ├── __init__.py
    ├── math_utils.py              # Математические утилиты
    └── trajectory_utils.py        # Работа с траекториями (интерполяция и т.д.)
```

=== КЛЮЧЕВЫЕ ПРИНЦИПЫ РЕАЛИЗАЦИИ ===

1. **Используй готовые функции**: Всегда предпочитай numpy, scipy, matplotlib встроенные функции вместо самописных реализаций.

2. **Физические модели в отдельном модуле**: Все теоретические формулы должны быть в models/theoretical_functions.py, чтобы их можно было легко менять.

3. **Автоматическое определение антикроссингов**: Области антикроссинга определяются автоматически из пересечений размеченных траекторий, без дополнительного ручного выделения.

4. **Модульность**: Каждая ФМР мода может независимо взаимодействовать с резонатором. Система должна поддерживать произвольное число ФМР мод.

5. **Интерактивность**: Пользователь размечает траектории кликами на contour-графике, программа выполняет всю аналитику автоматически.

=== ЭТАПЫ РЕАЛИЗАЦИИ ===

ЭТАП 1: Базовая структура и адаптер данных
Цель: Создать проект и подключить к существующим данным
Задачи:
- Создать структуру папок проекта
- Написать config/settings.py с базовыми настройками
- Реализовать core/data_loader.py - функции для загрузки данных S-параметров из текстовых файлов
  Формат данных: первая строка - частоты, первый столбец - поля, остальное - S-параметры в дБ
- Создать базовый main.py для тестирования загрузки данных
- Добавить функцию создания contour-графика (использовать matplotlib.contourf)
Результат: Можем загружать данные и показывать contour-график

ЭТАП 2: Интерактивный редактор траекторий и масок
Цель: Интерактивное рисование траекторий мод и выделение проблемных областей
Задачи:
- Реализовать core/trajectory_editor.py с классом для хранения траекторий и масок данных
- Создать visualization/interactive_interface.py - GUI на matplotlib для клика по contour-графику
- Режимы работы:
  * "cavity" - рисование траектории резонатора
  * "fmr" - рисование траектории ФМР моды  
  * "mask" - выделение областей с поломанными данными (исключить или снизить вес)
- Возможность добавлять/удалять точки траекторий кликами мыши
- Визуальное отображение траекторий и масок поверх contour-графика
- Сохранение/загрузка траекторий и масок в файл
Результат: Можем размечать траектории мод и проблемные области данных

ЭТАП 3: Генерация тестовых данных
Цель: Создать искусственные данные для проверки алгоритмов
Задачи:
- Создать utils/test_data_generator.py
- Функция генерации идеального антикроссинга двух мод по теоретической формуле
- Добавление реалистичного шума и фоновых сигналов  
- Генерация данных в том же формате, что и экспериментальные
- Создание нескольких тестовых случаев: простое антикроссинг, многомодовое, с шумом
Результат: Имеем контролируемые тестовые данные

ЭТАП 4: Базовая теоретическая модель
Цель: Формула для фитинга спектров S-параметров
Задачи:
- Реализовать models/theoretical_functions.py
- Функция s21_anticrossing_model(frequency, omega_c, gamma_ce, omega_m, gamma_ci, gamma_m, G)
  Входы: массив частот, параметры резонатора (omega_c, gamma_ce, gamma_ci) и ФМР (omega_m, gamma_m), связь G
  Выходы: массив значений S21 согласно теоретической формуле
- Использовать точную формулу из приложенного изображения:
  S21 ∝ 1 - (i*gamma_ce) / (omega - omega_c + i*(gamma_ce + gamma_ci) + G²/(omega - omega_m + i*gamma_m))
- Добавить возможность фитинга спектра при фиксированном магнитном поле
- Функция fit_single_spectrum(frequencies, s21_data, initial_params) для извлечения параметров
- Использовать scipy.optimize.curve_fit для нелинейного фитинга
Результат: Имеем функцию для фитинга экспериментальных спектров

ЭТАП 5: Базовый фитинг спектров с учетом траекторий и масок
Цель: Фитинг экспериментальных спектров с учетом размеченных траекторий и проблемных областей  
Задачи:
- Реализовать core/fitting_engine.py с классом SpectrumFitter
- Извлечение спектров S21(frequency) при разных значениях магнитного поля из 2D данных
- Аппроксимация размеченных траекторий (интерполяция, сглаживание) для получения ожидаемых резонансных частот
- Определение начальных приближений параметров из аппроксимированных траекторий:
  * ωc из траектории резонатора
  * ωm из траектории ФМР моды  
  * G из величины расщепления в области антикроссинга
- Применение масок: исключение или снижение веса точек в проблемных областях при фитинге
- Проверка соответствия: если найденные частоты сильно отличаются от траекторий, игнорировать этот спектр
- Фитинг каждого валидного спектра с помощью scipy.optimize.curve_fit
- Анализ зависимости параметров от магнитного поля
Результат: Можем извлекать параметры с учетом пользовательской разметки

ЭТАП 6: Визуализация результатов и итеративная коррекция
Цель: Отображение результатов фитинга и возможность коррекции
Задачи:
- Реализовать visualization/results_plotter.py
- Отображение результатов фитинга:
  * Наложение теоретических спектров S21 поверх экспериментальных
  * Показ аппроксимированных траекторий и извлеченных резонансных частот
  * Выделение замаскированных областей на графике
  * Графики параметров vs магнитное поле (особенно ωm(H))
- Графики качества фитинга (R², residuals) для каждого спектра
- Отображение извлеченных параметров в текстовом виде с неопределенностями
- Интерактивная коррекция после просмотра результатов:
  * Возможность подправить траектории мод
  * Изменение областей масок (добавить/убрать проблемные области)
  * Повторный автоматический фитинг после коррекции
Результат: Итеративное улучшение качества анализа через коррекцию разметки

ЭТАП 7: Многомодовая поддержка
Цель: Анализ нескольких ФМР мод одновременно
Задачи:
- Расширить theoretical_functions.py функцией multi_mode_anticrossing()
- Поддержка матрицы связей произвольного размера (N ФМР мод + 1 резонатор)
- Реализовать models/model_selector.py для автоматического выбора модели
- Одновременный фитинг всех антикроссингов с общими параметрами резонатора
- Обработка случаев, когда не все ФМР моды взаимодействуют с резонатором
Результат: Работа с произвольным числом ФМР мод

ЭТАП 8: Обработка результатов и экспорт
Цель: Сохранение и анализ результатов
Задачи:
- Реализовать core/results_manager.py
- Сохранение результатов в удобных форматах (JSON, CSV, текст)
- Экспорт графиков в высоком разрешении
- Статистический анализ неопределенностей параметров
- Сравнение результатов разных антикроссингов
- Создание отчетов с результатами анализа
Результат: Профессиональное оформление результатов

=== ТЕХНИЧЕСКИЕ ТРЕБОВАНИЯ ===

Библиотеки:
- numpy: математические вычисления, работа с массивами
- scipy: оптимизация (minimize, curve_fit), интерполяция, линейная алгебра  
- matplotlib: графики, интерактивный интерфейс
- json: сохранение конфигураций и результатов

Формат данных:
- Входные файлы: текстовые файлы S-параметров (первая строка - частоты, первый столбец - поля)
- Внутреннее представление: numpy массивы
- Траектории: списки точек (field, frequency) для каждой моды
- Маски: области (field_range, frequency_range) для исключения или снижения веса
- Результаты: словари с параметрами фитинга и их неопределенностями

Интерфейс:
- Основан на matplotlib с обработчиками событий мыши и клавиатуры
- Режимы работы переключаются клавишами
- Траектории рисуются кликами мыши
- Результаты отображаются в отдельных окнах

=== ФИЗИЧЕСКИЕ МОДЕЛИ ===

Базовая модель S-параметра для антикроссинга:
```
S21 ∝ 1 - (i*γce) / (ω - ωc + i*(γce + γci) + G²/(ω - ωm + i*γm))

где:
- ω - частота (переменная)
- ωc - частота резонатора
- ωm - частота ФМР моды (зависит от магнитного поля: ωm = ωm0 + γ*H)  
- γce, γci - параметры затухания резонатора
- γm - параметр затухания ФМР
- G - коэффициент связи между модами

Входы функции фитинга:
- frequencies: массив частот для расчета спектра
- s21_experimental: экспериментальные значения S21 при фиксированном поле H

Выходы функции фитинга:
- Оптимальные параметры: [ωc, γce, ωm, γci, γm, G]
- Неопределенности параметров
- Качество фитинга (R²)
- Теоретический спектр S21 с найденными параметрами
```

Многомодовая модель (N ФМР + 1 резонатор):
```
S21 включает вклады от всех ФМР мод:
Каждая ФМР мода добавляет свой член G²/(ω - ωm_i + i*γm_i) в знаменатель
```

=== ОЖИДАЕМЫЕ РЕЗУЛЬТАТЫ ===

Для каждого спектра и в целом для антикроссинга программа должна выдавать:
1. Параметры из формулы S21: ωc, γce, ωm(H), γci, γm, G
2. Зависимости параметров от магнитного поля (особенно линейность ωm(H) = ωm0 + γ*H)
3. Коэффициент связи G и его стабильность во всем диапазоне полей
4. Качество фитинга для каждого спектра (R², residuals)
5. Неопределенности всех извлеченных параметров
6. Графическое сравнение экспериментальных и теоретических спектров
7. Эволюция спектральных особенностей через область антикроссинга

=== ТРЕБОВАНИЯ К КАЧЕСТВУ КОДА ===

1. Каждая функция должна иметь docstring с описанием параметров и возвращаемых значений
2. Использовать type hints где возможно
3. Обрабатывать исключения и граничные случаи
4. Код должен быть модульным и легко тестируемым
5. Избегать глобальных переменных
6. Следовать PEP 8 стилю кодирования

=== ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ ===

Базовый workflow:
```python
from anticrossing_analyzer import AnticrossingAnalyzer

# 1. Загрузка данных и показ contour-графика
analyzer = AnticrossingAnalyzer('experimental_data.txt')
analyzer.show_contour_plot()

# 2. Интерактивная разметка траекторий и проблемных областей
analyzer.start_interactive_editor()
# Пользователь кликами рисует:
# - траектории резонатора и ФМР мод
# - области с поломанными данными (маски)

# 3. Первичный анализ
results = analyzer.analyze_with_trajectories()
analyzer.show_fit_results(results)

# 4. Итеративная коррекция (если нужно)
# Пользователь может подправить траектории и маски
analyzer.update_trajectories_and_masks()
results_improved = analyzer.analyze_with_trajectories()

# 5. Финальные результаты  
print(f"Coupling strength G: {results_improved.coupling_strength}")
print(f"Cavity parameters: ωc={results_improved.omega_c}, γce={results_improved.gamma_ce}")
print(f"FMR parameters: ωm0={results_improved.omega_m0}, γ={results_improved.gamma_fmr}")
print(f"Fit quality: R²={results_improved.r_squared}")
```

=== КРИТЕРИИ ГОТОВНОСТИ ЭТАПОВ ===

Каждый этап считается завершенным, когда:
1. Весь код этапа написан и протестирован
2. Создан простой пример использования  
3. Код интегрирован с предыдущими этапами
4. Нет критических ошибок или исключений
5. Функциональность этапа демонстрируется на тестовых данных

Начинай реализацию с Этапа 1. После завершения каждого этапа показывай результат и спрашивай одобрение перед переходом к следующему этапу.

УДАЧИ В РЕАЛИЗАЦИИ!